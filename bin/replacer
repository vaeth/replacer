#!/usr/bin/env python
# -*- coding: utf-8 -*-
# (C) Martin V\"ath <martin at mvath.de>
# SPDX-License-Identifier: MIT

from __future__ import print_function
import argparse
import fnmatch
import io
import locale
import os
import re
import sys
import warnings
warnings.filterwarnings("ignore", category=DeprecationWarning)

version = '3.4'

# Set localedir to e.g. '/usr/share/locale' to fix the gettext (nls) path.
# If localedir == '', the value is fetched from $REPLACER_NLS or $NLS.
# If localedir is None, gettext (nls) is not used.
localedir = ''

warnings.filterwarnings("ignore", category=DeprecationWarning)
try:
    import sre_parse
    have_sre_parse = "expand_template" in dir(sre_parse)
except ImportError:
    have_sre_parse = False
warnings.resetwarnings()

if localedir is not None:
    try:
        import gettext
    except ImportError:
        localedir = None

try:
    from colorama import Fore, Style
    have_colorama = True
except ImportError:
    have_colorama = False


have_gettext = False
if localedir is not None:
    if not localedir:  # Use $REPLACER_NLS as a fallback
        localedir = os.environ.get('REPLACER_NLS')
        if not localedir:  # Use $NLS as a fallback
            localedir = os.environ.get('NLS')
    try:
        gettext.install('replacer', localedir=localedir, names=['ngettext'])
        have_gettext = True
    except OSError:
        have_gettext = False

if have_gettext:
    def pgettext(id, message):
        msgid = id + '\x04' + message
        t = _(msgid)
        if t == msgid:  # Lookup failed
            return message
        return t

    def npgettext(id, msgid1, msgid2, n):
        msgid = id + '\0x04' + msgid1
        t = ngettext(msgid, msgid2, n)
        if t == msgid:  # Lookup failed
            if n == 1:
                return msgid1
            return msgid2
        return t
else:
    def _(message):
        return message

    def ngettext(msgid1, msgid2, n):
        if n == 1:
            return msgid1
        return msgid2

    def pgettext(id, message):
        return _(message)

    def npgettext(id, msgid1, msgid2, n):
        return ngettext(msgid1, msgid2, n)
N_ = ngettext
P_ = pgettext
NP_ = npgettext

if not have_colorama:
    class Fore:
        BLACK = '\033[30m'
        RED = '\033[31m'
        GREEN = '\033[32m'
        YELLOW = '\033[33m'
        BLUE = '\033[34m'
        MAGENTA = '\033[35m'
        CYAN = '\033[36m'
        WHITE = '\033[37m'

    class Style:
        BRIGHT = '\033[1m'
        DIM = '\033[2m'
        NORMAL = '\033[22m'
        RESET_ALL = '\033[0m'


class Effect:
    if hasattr(Style, 'ITALIC'):
        ITALIC = Style.ITALIC
    else:
        ITALIC = '\033[3m'
    if hasattr(Style, 'UNDERLINE'):
        ITALIC = Style.UNDERLINE
    else:
        UNDERLINE = '\033[4m'
    if hasattr(Style, 'BLINK'):
        BLINK = Style.BLINK
    else:
        BLINK = '\033[5m'
    if hasattr(Style, 'REVERSE'):
        REVERSE = Style.REVERSE
    else:
        REVERSE = '\033[7m'
    if hasattr(Style, 'INVISIBLE'):
        INVISIBLE = Style.INVISIBLE
    else:
        INVISIBLE = '\033[8m'
    if hasattr(Style, 'STRIKETHROUGH'):
        STRIKETHROUGH = Style.STRIKETHROUGH
    else:
        STRIKETHROUGH = '\033[9m'
    if hasattr(Style, 'RESET_ALL'):
        RESET_ALL = Style.RESET_ALL
    else:
        RESET_ALL = 'RESET'


class Colors:
    reset = Style.RESET_ALL

    def set_mode(self, mode='dark'):
        if mode == 'none':
            self._data = [
                None,  # before, unreplaced
                None,  # before, replaced
                None,  # at, unreplaced
                None,  # at, replaced
                None,  # after
                None,  # grep
                None,  # filename
            ]
        if mode == 'dark':
            self._data = [
                Fore.MAGENTA + Style.BRIGHT,  # before, unreplaced
                Fore.BLUE + Style.BRIGHT,  # before, replaced
                Fore.RED + Style.BRIGHT,  # at, unreplaced
                Fore.GREEN + Style.BRIGHT,  # at, replaced
                Fore.YELLOW + Style.BRIGHT,  # after
                Fore.YELLOW + Style.BRIGHT,  # grep
                Fore.MAGENTA + Style.BRIGHT,  # filename
            ]
        elif mode == 'light':
            self._data = [
                Fore.YELLOW,  # before, unreplaced
                Fore.CYAN,  # before, replaced
                Fore.RED + Style.BRIGHT,  # at, unreplaced
                Fore.BLUE + Style.BRIGHT,  # at, replaced
                Fore.MAGENTA + Style.BRIGHT,  # after
                Fore.MAGENTA + Style.BRIGHT,  # grep
                Fore.YELLOW + Style.BRIGHT,  # filename
            ]
        elif mode == 'style':
            self._data = [
                Effect.UNDERLINE,  # before, unreplaced
                Effect.UNDERLINE,  # before, replaced
                Effect.REVERSE,  # at, unreplaced
                Effect.REVERSE,  # at, replaced
                Effect.UNDERLINE,  # after
                Effect.REVERSE,  # grep
                None,  # filename
            ]
        else:
            raise ValueError('bad color mode “{0}”'.format(mode))

    def __init__(self, mode='dark'):
        self.set_mode(mode)

    def __getitem__(self, key):
        return self._data[key]


def get_parser():
    d = _(r'Interactively replace python regular expressions in files. '
          r'The specified SEARCH and REPLACE expressions are a regular '
          r'expression and replace string following the python syntax, '
          r'see e.g. https://docs.python.org/3/library/re.html or '
          r'https://docs.python.org/2/library/re.html (exact features '
          r'depending on your python interpreter). '
          r'For the replace string, see in particular the description of '
          r'the sub() function. In the terminology of the web pages, '
          r'the arguments (as passed by the shell) are treated as '
          r'“raw” strings.')
    p = argparse.ArgumentParser(description=d)
    a = p.add_argument
    global version
    a('-V', '--version', action='version',
      version='{0} {1}'.format('%(prog)s', version))
    a('-b', '--chars', action='store_true', help=P_(
      'help', r'chars (binary) mode: Treat chars instead of lines as units '
      r'when formatting visual output. Thus, BEFORE, AFTER, CONTEXT, and '
      r'printed numbers refer to character numbers instead of line numbers. '
      r'Newline characters are output visually as “\n”.'))
    a('-B', '--before', metavar=P_('help', 'BEFORE'),
      type=int, default=None, help=P_(
        'help', r'output lines of context before match'))
    a('-A', '--after', metavar=P_('help', 'AFTER'),
      type=int, default=None, help=P_(
        'help', r'output lines of context after match'))
    a('-C', '--context', metavar=P_('help', 'CONTEXT'),
      type=int, default=0, help=P_(
        'help', r'output lines of context before and after match'))
    a('-p', '--plain-search', action='store_true', help=P_(
      'help', r'treat search expression as plain string'))
    a('-P', '--plain-replace', action='store_true', help=P_(
      'help', r'treat replace expression as plain string'))
    a('-e', '--encoding', metavar=P_('help', 'ENCODING'),
      default=None, help=P_(
      'help', r'file encoding, e.g. utf-8, cp1252, cp850, latin-1, see '
      r'https://docs.python.org/3/library/codecs.html#standard-encodings '
      r'(if not specified, empty or when the special value “binary” or '
      r'“bytes” is used, the file is considered as a byte stream)'))
    a('-E', '--encoding-fallback', metavar=P_('help', 'ENCODING'),
      default=None, help=P_(
      'help', r'file encoding if the -e encoding fails. '
      r'Use the empty string or the argument of -e to avoid retrying.'))
    a('-k', '--keep', action='store_true', help=P_(
      'help', r'try to keep timestamps when modifying files'))
    a('-g', '--grep', action='store_true', help=P_(
      'help', r'grep mode, only show matches'))
    a('-c', '--count', action='store_true', help=P_(
      'help', r'grep mode, count matches in files'))
    a('-l', '--list', action='store_true', help=P_(
      'help', r'grep mode, list files with matches'))
    a('-I', '--ignorecase', action='store_true', help=P_(
      'help', r'ignore case in search expression'))
    a('-M', '--multiline', action='store_true', help=P_(
      'help', r'make ^ and $ in search expression consider each line'))
    a('-S', '--dotall', action='store_true', help=P_(
      'help', r'make . in search expression match newline, too'))
    a('-U', '--unicode', action='store_true', help=P_(
      'help', r'make \w \W \b \B in search expression follow unicode rules'))
    a('-L', '--locale', action='store_true', help=P_(
      'help', r'make \w \W \b \B in search expression follow locale'))
    a('-X', '--verbose', action='store_true', help=P_(
      'help', r'allow comments in search expression'))
    a('-r', '--recursive', action='store_true', help=P_(
      'help', r'recurse if FILE is a directory. When recursing, non-files and '
      r'symbolic links to directories are tacitly ignored.'))
    a('-s', '--skip', metavar=P_('help', 'PATTERN'),
      action='append', default=[], help=P_(
      'help', r'skip files/dirs whose paths match PATTERN. '
      r'This option is accumulative'))
    a('-R', '--require', metavar=P_('help', 'PATTERN'),
      action='append', default=[], help=P_(
      'help',  r'skip files/dirs whose paths do not match PATTERN. '
      r'This option is accumulative'))
    a('-H', '--colors', default='dark',
      choices=['none', 'dark', 'light', 'style'], help=P_(
        'help', r'set highlight mode. Default is --colors=dark. '
        r'There are choices appropriate for terminals with dark (default) or '
        r'light background or using only style attributes like reverse '
        r'or underline. The latter might not work on all terminals. '
        r'Under windows, it might be necessary to have the colorama package '
        r'or ANSI emulation installed unless --colors=none is used.'))
    a('-y', '--yes', action='count', default=0, help=P_(
      'help', r'always replace (twice to always write)'))
    a('-q', '--quiet', action='store_true', help=P_(
      'help', r'do not print matches, quiet grep'))
    a('-D', '--debug', action='store_true')
    a('search', metavar=P_('help', 'SEARCH'), help=P_(
      'help', r'search expression'))
    a('replace', metavar=P_('help', 'REPLACE'), help=P_(
      'help', r'replace string'))
    a('files', metavar=P_('help', 'FILE'), nargs='*', help=P_(
      'help', r'files to process'))
    return p


def write(*args, **kwargs):
    print(*args, end='', **kwargs)


def write_repr_match(match):
    return repr(match.group(0)).replace("'", '')


def write_printable(text):
    write(write_printable.re.sub(write_repr_match, text))
write_printable.re = re.compile('[\x00-\x09\x0B-\x1F]')


def write_repr(text):
    write(write_repr.re.sub(write_repr_match, text))
write_repr.re = re.compile('[\x00-\x1F]')


def write_printable_bytes(text):
    write_printable(text.decode('utf-8', errors='backslashreplace'))


def write_repr_bytes(text):
    write_repr(text.decode('utf-8', errors='backslashreplace'))


def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)


def warn(msg, **kwargs):
    eprint('warning: {0}'.format(msg), **kwargs)


def my_input(msg):
    try:
        return raw_input(msg)
    except NameError:
        return input(msg)


class MatchList:
    def _linestart(self, index):
        if index <= 0:
            return 0
        previous = self.text.rfind(self._newline, 0, index)
        if previous < 0:
            return 0
        return previous + 1

    def empty(self):
        return (not self._list)

    def length(self):
        return len(self._list)

    def have(self):
        return (self._index < len(self._list))

    def finalize(self):
        del self._previous
        if self.empty():
            return
        self._index = 0
        self._pos = self._list[0][0]
        if self._chars:
            return
        self._line_number = self.text.count(self._newline, 0, self._pos)
        self._line_start = self._linestart(self._pos)
        self._line_printed = 0

    def add(self, start, end, replace=None):
        if self.text[start:end] == replace:
            return
        entry = [start - self._previous, end - start]
        if not self._grep:
            entry.append(replace)
        self._previous = end
        self._list.append(entry)

    def next(self, replace):
        c = self._list[self._index]
        pos = self._pos
        if replace:
            c = self._list[self._index]
            sub = c[2]
            self.text = self.text[:pos] + sub + self.text[pos + c[1]:]
            l = c[1] = len(sub)
            c[2] = True
        else:
            l = c[1]
            c[2] = False
        npos = pos + l
        if not self._chars:
            self._line_number += self.text.count(self._newline, pos, npos)
            self._line_printed = self._line_number + self.after + 1
        self._index += 1
        if not self.have():
            return False
        pos = npos
        npos = pos + self._list[self._index][0]
        if not self._chars:
            self._line_number += self.text.count(self._newline, pos, npos)
            self._line_start = self._linestart(npos)
        self._pos = npos
        return True

    def _pos_index_in_pattern(self, start):
        index = self._index
        in_pattern = False
        pos = self._pos
        while True:
            if in_pattern:
                npos = pos - self._list[index][1]
                if npos < start:
                    break
                pos = npos
                in_pattern = False
            else:
                if index == 0:
                    break
                npos = pos - self._list[index][0]
                if npos < start:
                    break
                pos = npos
                in_pattern = True
                index -= 1
        return (pos, index, in_pattern)

    def colored_filename(self, append=':'):
        if self.filename is None:
            return ''
        color = self.colors[6]
        if color:
            return (color + self.filename + self.colors.reset + append)
        return (self.filename + append)

    def _write_number(self, number, mode):
        if self._grep:
            mode = ''
        write('{0}{1}{2}:'.format(self.colored_filename(), number, mode))

    def _write_line_number(self, line_number, mode=' '):
        self._write_number(line_number + 1, mode)

    def _write_char_number(self, char_number, mode=' '):
        self._write_number(char_number + 1, mode)

    def _write_color(self, replace=None, index=None):
        if self._grep:
            color = self.colors[5]
        elif index is None:
            color = self.colors[2 + replace]
        else:
            replace = self._list[index][2]
            if isinstance(replace, bool):
                color = self.colors[replace]
            else:
                color = self.colors[4]
        if color:
            write(color)
            return self.colors.reset
        return None

    def _write_substring(self, start, end):
        self._write_printable(self.text[start:end])

    def _output_lines_before(self):
        if not self.before:
            return
        start = self._line_start
        line_number = self._line_number
        starts = []
        for i in range(self.before):
            if start == 0 or line_number - len(starts) <= self._line_printed:
                break
            start = self._linestart(start - 1)
            starts.append(start)
        if not starts:
            return
        line_number -= len(starts)
        prevstart = None
        for start in reversed(starts):
            if prevstart:
                self._write_line_number(line_number)
                self._write_substring(prevstart, start)
                line_number += 1
            prevstart = start
        self._write_line_number(line_number)
        self._write_substring(prevstart, self._line_start)

    def _output_to_lineend(self, current, pos, index, in_pattern):
        newline = self.text.find(self._newline, current)
        if newline < 0:
            newline = len(self.text)
            nextline = None
        else:
            newline += 1
            nextline = newline
        reset = None
        toggle = False
        while True:
            last = (pos is None or pos >= newline)
            if last:
                end = newline
            else:
                end = pos
            if current < end:
                if in_pattern:
                    reset = self._write_color(index=index)
                elif reset:
                    write(reset)
                    reset = None
                self._write_substring(current, end)
                current = end
            if last:
                break
            if in_pattern:
                in_pattern = False
                index += 1
                if index >= len(self._list):
                    pos = None
                else:
                    pos += self._list[index][0]
            else:
                in_pattern = True
                pos += self._list[index][1]
        if reset:
            write(reset)
        if nextline is None:
            print('<EOF>')
        elif nextline >= len(self.text):
            nextline = None
        return (nextline, pos, index, in_pattern)

    def _output_lines_at(self, pos, index, in_pattern, replace):
        if replace:
            mode = '+'
        else:
            mode = '-'
        line_number = self._line_number
        current = self._line_start
        self._write_line_number(line_number, mode=mode)
        reset = None
        if current < pos:
            if in_pattern:
                reset = self._wrote_color(index=index)
                in_pattern = False
            else:
                in_pattern = True
            self._write_substring(current, pos)
        while index < self._index:
            if in_pattern:
                reset = self._write_color(index=index)
                npos = pos + self._list[index][1]
                in_pattern = False
            else:
                if reset:
                    write(reset)
                    reset = None
                index += 1
                npos = pos + self._list[index][0]
                in_pattern = True
            self._write_substring(pos, npos)
            pos = npos
        current = pos
        pos += self._list[index][1]
        if replace:
            output = self._list[index][2]
        else:
            output = self.text[current:pos]
        output_current = 0
        newline = -1
        while output_current < len(output):
            if line_number > self._line_number:
                self._write_line_number(line_number, mode=mode)
            reset = self._write_color(replace=replace)
            newline = output.find(self._newline, output_current)
            if newline < 0:
                self._write_printable(output[output_current:])
                if reset:
                    write(reset)
                break
            newline += 1
            self._write_printable(output[output_current:newline])
            if reset:
                write(reset)
            output_current = newline
            line_number += 1
        current = pos
        index += 1
        if index < len(self._list):
            pos += self._list[index][0]
        else:
            pos = None
        if newline < 0:  # match does not close with newline
            (current, pos, index, in_pattern) = \
                self._output_to_lineend(current, pos, index, False)
        return (line_number + 1, current, pos, index, in_pattern)

    def _output_lines_after(self, startline, current, pos, index,
                            in_pattern):
        if not self.after:
            return
        for line_number in range(startline, startline + self.after):
            if current is None:
                break
            self._write_line_number(line_number)
            (current, pos, index, in_pattern) = \
                self._output_to_lineend(current, pos, index, in_pattern)

    def _output_lines_nogrep(self):
        self._output_lines_before()
        (pos, index, in_pattern) = self._pos_index_in_pattern(self._line_start)
        self._output_lines_at(pos, index, in_pattern, False)
        (startline, current, pos, index, in_pattern) = \
            self._output_lines_at(pos, index, in_pattern, True)
        self._output_lines_after(startline, current, pos, index, in_pattern)

    def _output_next_lines_grep(self):
        self._output_lines_before()
        current = self._line_start
        (pos, index, in_pattern) = self._pos_index_in_pattern(current)
        line_number = self._line_number
        lines_to_print = self.after + 1
        while lines_to_print > 0:
            self._write_line_number(line_number)
            (current, npos, index, in_pattern) = \
                self._output_to_lineend(current, pos, index, in_pattern)
            if current is None:
                return False
            line_number += 1
            if in_pattern:
                lines_to_print = self.after + 1
            elif pos is not None and (npos is None or npos != pos):
                lines_to_print = self.after
            else:
                lines_to_print -= 1
            pos = npos
        if pos is None:
            return False
        self._line_printed = line_number
        self._line_number = line_number + \
            self.text.count(self._newline, current, pos)
        self._index = index
        self._pos = pos
        self._line_start = self._linestart(pos)
        return True

    def _output_chars(self, current, pos, index, in_pattern, finish):
        reset = None
        while True:
            last = (pos is None or pos >= finish)
            if last:
                end = finish
            else:
                end = pos
            if current < end:
                if in_pattern:
                    reset = self._write_color(index=index)
                elif reset:
                    write(reset)
                    reset = None
                self._write_substring(current, end)
                current = end
            if last:
                break
            if in_pattern:
                in_pattern = False
                index += 1
                if index >= len(self._list):
                    pos = None
                else:
                    pos += self._list[index][0]
            else:
                in_pattern = True
                pos += self._list[index][1]
        if reset:
            write(reset)

    def _output_chars_at(self, current, npos, replace, replace_empty,
                         b_pos, b_index, b_in_pattern,
                         e_pos, e_index, e_finish):
        if replace is not None:
            mode = '+'
        else:
            mode = '-'
        self._write_char_number(current, mode=mode)
        if self.before:
            self._output_chars(current, b_pos, b_index, b_in_pattern,
                               self._pos)
        if not replace_empty:
            reset = self._write_color(replace=not not replace)
            if replace is None:
                self._write_substring(self._pos, npos)
            else:
                self._write_printable(replace)
            if reset:
                write(reset)
        if self.after:
            self._output_chars(npos, e_pos, e_index, False, e_finish)
        print()

    def _output_chars_nogrep(self):
        current = self._pos
        match = self._list[self._index]
        match_len = match[1]
        npos = current + match_len
        if self.after:
            e_finish = npos + self.after
            if e_finish > len(self.text):
                e_finish = len(self.text)
            e_pos = None
            e_index = self._index + 1
            if e_index < len(self._list) and npos < e_finish:
                e_pos = npos + self._list[e_index][0]
        else:
            (e_current, e_pos, e_index, e_finish) = (None, None, None, None)
        if self.before:
            current -= self.before
            if current < 0:
                current = 0
            (b_pos, b_index, b_in_pattern) = \
                self._pos_index_in_pattern(current)
        else:
            (b_pos, b_index, b_in_pattern) = (None, None, None)
        self._output_chars_at(current, npos, None, not match_len,
                              b_pos, b_index, b_in_pattern,
                              e_pos, e_index, e_finish)
        replace = match[2]
        self._output_chars_at(current, npos, replace, not replace,
                              b_pos, b_index, b_in_pattern,
                              e_pos, e_index, e_finish)

    def _output_next_chars_grep(self):
        current = pos = self._pos
        if self.before:
            current -= self.before
            if current < 0:
                current = 0
        self._write_char_number(current)
        if current < pos:
            self._write_substring(current, pos)
        index = self._index
        npos = pos + self._list[index][1]
        in_pattern = True
        reset = None
        while True:
            if in_pattern:
                reset = self._write_color(index=index)
            elif npos > finish + self.before:
                break
            self._write_substring(pos, npos)
            if reset:
                write(reset)
                reset = None
            pos = npos
            if in_pattern:
                finish = npos + self.after + 1
                if finish > len(self.text):
                    finish = len(self.text)
                index += 1
                if index >= len(self._list):
                    npos = None
                    break
                npos += self._list[index][0]
                in_pattern = False
            else:
                npos += self._list[index][1]
                in_pattern = True
        if finish > len(self.text):
            finish = len(self.text)
        if pos < finish:
            self._write_substring(pos, finish)
        print()
        if npos is None:
            return False
        self._index = index
        self._pos = npos
        return True

    def __init__(self, text, grep=False, chars=False):
        self.before = 0
        self.after = 0
        self.colors = Colors()
        self.text = text
        self._grep = grep
        self._chars = chars
        self._list = []
        self._previous = 0
        if hasattr(text, 'encode'):  # python2: str, unicode or python3: str
            self._newline = '\n'
            if chars:
                self._write_printable = write_repr
            else:
                self._write_printable = write_printable
        else:
            self._newline = b'\n'
            if chars:
                self._write_printable = write_repr_bytes
            else:
                self._write_printable = write_printable_bytes
        if chars:
            if grep:
                self.output_next_grep = self._output_next_chars_grep
            else:
                self.output_nogrep = self._output_chars_nogrep
        else:
            if grep:
                self.output_next_grep = self._output_next_lines_grep
            else:
                self.output_nogrep = self._output_lines_nogrep


class Matcher:
    def __init__(self, search, replace=None, plain_search=False,
                 plain_replace=False, flags=0, quick=False):
        self._quick = False
        if plain_search:
            if type(search) is str:
                search = re.sub(r'[a-zA-Z_]', r'\\\0', search)
            else:
                search = re.sub(br'[a-zA-Z_]', br'\\\0', search)
        self._re = re.compile(search, flags)
        if replace is None:
            self._plain_replace = True
            self._replace = None
            if quick:
                self._quick = True
            return
        if plain_replace:
            self._plain_replace = True
            self._replace = replace
        elif have_sre_parse:  # cf _subx() in re.py for the undocumented usage:
            template = sre_parse.parse_template(replace, self._re)
            if not template[0] and len(template[1]) == 1:
                self._plain_replace = True
                self._replace = template[1][0]
            else:
                self._plain_replace = False
                self._replace = template
        else:  # poor man's fallback
            self._plain_replace = False
            self._replace = replace

    def get_match_list(self, text, chars=False):
        match_list = MatchList(text, grep=(self._replace is None), chars=chars)
        for match in self._re.finditer(text):
            if self._plain_replace:
                replace = self._replace
            elif have_sre_parse:
                replace = sre_parse.expand_template(self._replace, match)
            else:   # poor man's fallback:
                replace = match.expand(self._replace)
            match_list.add(match.start(), match.end(), replace)
            if self._quick:
                return match_list
        match_list.finalize()
        return match_list


def ask_replace():
    while True:
        key = my_input(ask_replace.msg)
        try:
            answer = ask_replace.dictionary[key]
            break
        except KeyError:
            continue
    if answer == 's':
        sys.exit(0)
    return answer
ask_replace.msg = P_(
    'replace', 'y(es)/n(o)/r(est of file)/q(uit this file)/a(lways)/'
    'A(lways quiet)/s(top all) ')
ask_replace.dictionary = {
    P_('replace', 's'): 's',
    P_('replace', 'y'): 'y',
    P_('replace', 'n'): 'n',
    P_('replace', 'r'): 'r',
    P_('replace', 'q'): 'q',
    P_('replace', 'a'): 'a',
    P_('replace', 'A'): 'A',
}


def ask_write(filename):
    msg = ask_write.msg.format(filename)
    while True:
        key = my_input(msg)
        try:
            answer = ask_write.dictionary[key]
            break
        except KeyError:
            continue
    if answer == 's':
        sys.exit(0)
    return answer
ask_write.msg = P_(
    'write', 'write changes to {0}? '
    'y(es)/n(o)/w(rite always)/s(top all) ')
ask_write.dictionary = {
    P_('replace', 's'): 's',
    P_('replace', 'y'): 'y',
    P_('replace', 'n'): 'n',
    P_('replace', 'w'): 'w',
}


def close_noexcept(file):
    try:
        file.close()
    except KeyboardInterrupt:
        raise
    except Exception:
        pass


def normalize_encoding(encoding):
    if encoding is None or not encoding or encoding == 'bytes':
        return 'binary'
    return encoding


class Action:
    def _slurp(self, filename, encoding=None):
        if encoding is None:
            self._encoding_current = self._encoding
        else:
            self._encoding_current = encoding
        try:
            if self._encoding_current != 'binary':
                file = io.open(filename, 'r', encoding=self._encoding_current,
                               newline='\n')
            else:
                file = io.open(filename, 'rb')
                self._matcher = self._matcher_byte
        except KeyboardInterrupt:
            raise
        except Exception as e:
            warn(_('cannot open {0} for reading: {1}').format(filename, e))
            return None
        try:
            text = file.read()
        except UnicodeDecodeError as e:
            close_noexcept(file)
            if encoding_override is None:
                warn(_('fallback encoding fails, too: {0}').format(e))
                return None
            if self._encoding_fallback is not None:
                warn(_('switching encoding {0}->{1} for {2}: {3}').
                     format(self._encoding, self._encoding_fallback,
                            filename, e))
                return self._slurp(filename, self._encoding_fallback)
            warn(_('{0} encoding error for {1}: {2}').
                 format(self._encoding, filename, e))
            return None
        except KeyboardInterrupt:
            raise
        except Exception as e:
            close_noexcept(file)
            warn(_('error when reading {0}: {1}').format(filename, e))
            return None
        try:
            file.close()
        except KeyboardInterrupt:
            raise
        except Exception as e:
            warn(_('error when closing {0} after reading: {1}').
                 format(filename, e))
            return None
        if type(text) is bytes:
            if self._matcher_byte is None:
                self._matcher_byte = self._matcher_fabric(unicode=False)
                if self._matcher_unicode is not None:
                    self._matcher_fabric = None  # Free unneeded memory
            self._matcher = self._matcher_byte
        else:
            if self._matcher_unicode is None:
                self._matcher_unicode = self._matcher_fabric(unicode=True)
                if self._matcher_byte is not None:
                    self._matcher_fabric = None  # Free unneeded memory
            self._matcher = self._matcher_unicode
        return text

    def _write(self, filename, text):
        stat = None
        if self._keep:
            try:
                stat = os.stat(filename)
            except KeyboardInterrupt:
                raise
            except Exception as e:
                stat = None
                warn(_('cannot get timestamp of {0}: {1}').format(filename, e))
        try:
            if self._encoding_current != 'binary':
                file = io.open(filename, 'w', encoding=self._encoding_current,
                               newline='\n')
            else:
                file = io.open(filename, 'wb')
        except KeyboardInterrupt:
            raise
        except Exception as e:
            warn(_('cannot open {0} for writing: {1}').format(filename, e))
            return
        try:
            file.write(text)
        except KeyboardInterrupt:
            raise
        except Exception as e:
            warn(_('write error to {0}: {1}').format(filename, e))
        try:
            file.close()
        except KeyboardInterrupt:
            raise
        except Exception as e:
            warn(_('error when closing {0} after writing: {1}').
                 format(filename, e))
        if stat is not None:
            try:
                os.utime(filename, (stat.st_atime, stat.st_mtime))
            except KeyboardInterrupt:
                raise
            except Exception as e:
                warn(_('cannot set timestamp of {0}: {1}').format(filename, e))

    def _exit(self):
        if self._grep and not self._have:
            sys.exit(1)  # grep mode with no match
        sys.exit(0)

    def _process(self, filename):
        text = self._slurp(filename)
        if text is None:
            return
        match_list = self._matcher.get_match_list(text, self._chars)
        match_list.colors = self._colors
        match_list.before = self._before
        match_list.after = self._after
        match_list.filename = filename
        have = (not match_list.empty())
        if self._grep:
            if have:
                self._have = True
                if self._quiet:
                    self._exit()
                if self._list:
                    print(match_list.colored_filename(append=''))
                    return
            if self._quiet:
                return
            if self._count:
                print('{0}{1}'.format(match_list.colored_filename(),
                                      match_list.length()))
                return
            while have:
                have = match_list.output_next_grep()
            return
        rest = self._always_replace
        changed = False
        while have:
            if not self._quiet:
                match_list.output_nogrep()
            replace = False
            if rest:
                replace = True
            else:
                answer = ask_replace()
                if answer == 'y':
                    replace = True
                elif answer == 'r':
                    replace = rest = True
                elif answer == 'a':
                    replace = rest = self._always_replace = True
                elif answer == 'A':
                    replace = rest = self._always_replace = self._quiet = True
                elif answer == 'q':
                    break
            if replace:
                changed = True
            have = match_list.next(replace)
        if not changed:
            return
        write = self._always_write
        if not write:
            answer = ask_write(filename)
            if answer == 'y':
                write = True
            elif answer == 'w':
                write = self._always_write = True
        if write:
            self._write(filename, match_list.text)

    def _test_skip(self, filename):
        for skip in self._skip:
            if fnmatch.fnmatch(filename, skip):
                return True
        if not self._require:
            return False
        for require in self._require:
            if fnmatch.fnmatch(filename, require):
                return False
        return True

    def _recurse(self, dir):
        for (dirpath, dirnames, filenames) in os.walk(dir):
            dirnames[:] = \
                [name for name in sorted(dirnames)
                 if not self._test_skip(os.path.join(dirpath, name))]
            for name in sorted(filenames):
                filename = os.path.join(dirpath, name)
                if not self._test_skip(filename) and os.path.isfile(filename):
                    self._process(filename)

    def _parse_error(self, msg):
        self._parser.print_usage(file=sys.stderr)
        raise argparse.ArgumentTypeError(msg)

    def _main(self):
        self._parser = get_parser()
        options = self._parser.parse_args()
        self._debug = options.debug
        self._chars = options.chars
        files = options.files
        search = options.search
        replace = options.replace
        if options.grep or options.count or options.list:
            self._grep = True
            if options.replace is not None:
                files.insert(0, options.replace)
            replace = None
            self._list = options.list
            self._count = options.count
        else:
            self._grep = False
        if not files:
            self._parse_error(_('no files specified'))
        self._colors = Colors(options.colors)
        self._before = self._after = options.context
        if options.before is not None:
            self._before = options.before
        if options.after is not None:
            self._after = options.after
        if self._before < 0:
            self._parse_error(
                _('--before argument {0} is negative').format(self._before))
        if self._after < 0:
            self._parse_error(
                _('--after argument {0} is negative').format(self._after))
        flags = 0
        if options.ignorecase:
            flags |= re.IGNORECASE
        if options.multiline:
            flags |= re.MULTILINE
        if options.dotall:
            flags |= re.DOTALL
        if options.unicode:
            flags |= re.UNICODE
        if options.locale:
            flags |= re.LOCALE
        if options.verbose:
            flags |= re.VERBOSE
        self._encoding = normalize_encoding(options.encoding)
        self._encoding_fallback = None
        encoding_fallback = ''
        if self._encoding != 'binary':
            encoding_fallback = normalize_encoding(options.encoding_fallback)
            if encoding_fallback != self._encoding:
                self._encoding_fallback = encoding_fallback
        self._keep = options.keep
        self._quiet = options.quiet
        self._skip = options.skip
        self._require = options.require
        if options.yes:
            self._always_replace = True
        else:
            self._always_replace = False
        if options.yes > 1:
            self._always_write = True
        else:
            self._always_write = False

        # Now the main configuration: Generate appropriate matcher_fabric()
        # which uses local variable settings as closures

        self._matcher_byte = self._matcher_unicode = None
        if type(search) is bytes:  # The python2 case

            def search_replace_byte():
                return (search, replace)

            def search_replace_unicode():
                search_unicode = search.decode('utf-8')
                replace_unicode = None
                if replace is not None:
                    replace_unicode = replace.decode('utf-8')
                return (search_unicode, replace_unicode)
        else:  # The python3 case

            def search_replace_unicode():
                return (search, replace)

            def search_replace_byte():
                search_byte = search.encode('utf-8')
                replace_byte = None
                if replace is not None:
                    replace_byte = replace.encode('utf-8')
                return (search_byte, replace_byte)

        def matcher_fabric(unicode=False):
            if unicode:
                (search_coded, replace_coded) = search_replace_unicode()
            else:
                (search_coded, replace_coded) = search_replace_byte()
            return Matcher(
                search_coded, replace_coded,
                plain_search=options.plain_search,
                plain_replace=options.plain_replace,
                flags=flags,
                quick=self._quiet,
            )
        self._matcher_fabric = matcher_fabric

        # Process files

        for filename in files:
            if self._test_skip(filename):
                continue
            if os.path.isfile(filename):
                self._process(filename)
            elif os.path.isdir(filename):
                if options.recursive:
                    self._recurse(filename)
                else:
                    warn(_('forgotten --recursive: directory: {0}').
                         format(filename))
            else:
                warn(_('not an accessible file: {0}').format(filename))

    def __init__(self):
        self._debug = False
        try:
            locale.setlocale(locale.LC_ALL, '')
            self._main()
        except KeyboardInterrupt:
            sys.exit(130)
        except SystemExit:
            raise
        except Exception as e:
            if self._debug:
                raise
            eprint(_('error: {0}').format(e))
            sys.exit(2)

Action()
