#!/usr/bin/env python
# (C) Martin V\"ath <martin@mvath.de>

from __future__ import print_function
import argparse
import codecs
import fnmatch
import locale
import os
import re
import sys

try:
    import sre_parse
    have_sre_parse = True
except ImportError:
    have_sre_parse = False

try:
    from colorama import Fore, Style
except ImportError:
    class Fore:
        BLACK = '\033[30m'
        RED = '\033[31m'
        GREEN = '\033[32m'
        YELLOW = '\033[33m'
        BLUE = '\033[34m'
        MAGENTA = '\033[35m'
        CYAN = '\033[36m'
        WHITE = '\033[37m'

    class Style:
        BRIGHT = '\033[1m'
        DIM = '\033[2m'
        NORMAL = '\033[22m'
        RESET_ALL = '\033[0m'


class Colors:
    reset = Style.RESET_ALL

    def set_mode(self, mode='dark'):
        if mode == 'none':
            self._data = [
                None,  # before, unreplaced
                None,  # before, replaced
                None,  # at, unreplaced
                None,  # at, replaced
                None,  # after or grep
                None,  # filename
            ]
        if mode == 'dark':
            self._data = [
                Fore.MAGENTA,  # before, unreplaced
                Fore.BLUE + Style.BRIGHT,  # before, replaced
                Fore.RED + Style.BRIGHT,  # at, unreplaced
                Fore.GREEN + Style.BRIGHT,  # at, replaced
                Fore.YELLOW + Style.BRIGHT,  # after or grep
                Fore.MAGENTA + Style.BRIGHT,  # filename
            ]
        elif mode == 'light':
            self._data = [
                Fore.YELLOW,  # before, unreplaced
                Fore.CYAN,  # before, replaced
                Fore.RED + Style.BRIGHT,  # at, unreplaced
                Fore.BLUE + Style.BRIGHT,  # at, replaced
                Fore.MAGENTA + Style.BRIGHT,  # after or grep
                Fore.YELLOW + Style.BRIGHT,  # filename
            ]
        else:
            raise ValueError('bad color mode “{0}”'.format(mode))

    def __init__(self, mode='dark'):
        self.set_mode(mode)

    def __getitem__(self, key):
        return self._data[key]


def get_parser():
    d = (r'Interactively replace python regular expressions in files. '
         r'The specified SEARCH and REPLACE expressions are a regular '
         r'expression and replace string following the python syntax, '
         r'see e.g. https://docs.python.org/3/library/re.html or '
         r'https://docs.python.org/2/library/re.html (exact features '
         r'depending on your python interpreter). '
         r'For the replace string, see in particular the description of '
         r'the sub() function. In the terminology of the web pages, '
         r'the arguments (as passed by the shell) are treated as '
         r'“raw” strings.')
    p = argparse.ArgumentParser(description=d)
    a = p.add_argument
    a('-V', '--version', action='version', version='%(prog)s 1.2')
    a('-b', '--chars', action='store_true',
      help=r'chars (binary) mode: Treat chars instead of lines as units '
      r'when formatting visual output. Thus, --before and --after and '
      r'printed numbers refer to character numbers instead of line numbers. '
      r'Newline characters are output visually as “\n”. '
      r'For binary files, this option is often combined with -e cp850')
    a('-B', '--before', type=int, default=None,
      help=r'add lines of context before match')
    a('-A', '--after', type=int, default=None,
      help=r'add lines of context after match')
    a('-C', '--context', type=int, default=0,
      help=r'add lines of context before and after match')
    a('-p', '--plain-search', action='store_true',
      help=r'treat search expression as plain string')
    a('-P', '--plain-replace', action='store_true',
      help=r'treat replace expression as plain string')
    a('-e', '--encoding', default='utf8',
      help=r'file encoding, e.g. utf8 (default), cp1252, or cp850')
    a('-E', '--encoding-fallback', default='cp1252',
      help=r'file encoding if the -e encoding fails, e.g. cp1252 (default) '
      r'or cp850. Use the empty string or the value of -e to avoid retrying.')
    a('-k', '--keep', action='store_true',
      help=r'try to keep timestamps when modifying files')
    a('-g', '--grep', action='store_true',
      help=r'grep mode, only show matches')
    a('-c', '--count', action='store_true',
      help=r'grep mode, count matches in files')
    a('-l', '--list', action='store_true',
      help=r'grep mode, list matches in files')
    a('-I', '--ignorecase', action='store_true',
      help=r'ignore case in search expression')
    a('-M', '--multiline', action='store_true',
      help=r'make ^ and $ in search expression consider each line')
    a('-S', '--dotall', action='store_true',
      help=r'make . in search expression match newline, too')
    a('-U', '--unicode', action='store_true',
      help=r'make \w \W \b \B in search expression follow unicode rules')
    a('-L', '--locale', action='store_true',
      help=r'make \w \W \b \B in search expression follow locale')
    a('-X', '--verbose', action='store_true',
      help=r'allow comments in search expression')
    a('-r', '--recursive', action='store_true',
      help=r'recurse if FILE is a directory. When recursing, non-files and '
      r'symbolic links to directories are tacitly ignored.')
    a('-s', '--skip', action='append', default=[],
      help=r'skip files/dirs whose paths match the specified unix pattern. '
      r'This option is accumulative')
    a('-H', '--colors', choices=['none', 'dark', 'light'], default='dark',
      help=r'highlight mode')
    a('-y', '--yes', action='count', default=0,
      help=r'always replace (twice to always write)')
    a('-q', '--quiet', action='store_true',
      help=r'do not print matches, quiet grep')
    a('-D', '--debug', action='store_true')
    a('search', metavar='SEARCH', help=r'search expression')
    a('replace', metavar='REPLACE', help=r'replace string')
    a('files', metavar='FILE', nargs='*', help=r'files to process')
    return p


def write(*args, **kwargs):
    print(*args, end='', **kwargs)


def write_repr_match(match):
    return repr(match.group(0)).replace("'", '')


def write_printable(text):
    write(write_printable.nonprintable.sub(write_repr_match, text))
write_printable.nonprintable = re.compile('[\x00-\x09\x0B-\x1F]')


def write_repr(text):
    write(write_repr.nonprintable.sub(write_repr_match, text))
write_repr.nonprintable = re.compile('[\x00-\x1F]')


def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)


def warn(msg, **kwargs):
    eprint('warning: {0}'.format(msg), **kwargs)


def my_input(msg):
    try:
        return raw_input(msg)
    except NameError:
        return input(msg)


def linestart(text, index):
    if index <= 0:
        return 0
    previous = text.rfind('\n', 0, index)
    if previous < 0:
        return 0
    return previous + 1


class MatchList:
    def empty(self):
        return (not self._list)

    def length(self):
        return len(self._list)

    def have(self):
        return (self._index < len(self._list))

    def finalize(self):
        del self._previous
        if self.empty():
            return
        self._index = 0
        self._pos = self._list[0][0]
        if self._chars:
            return
        self._line_number = self.text.count('\n', 0, self._pos)
        self._line_start = linestart(self.text, self._pos)
        self._line_printed = 0

    def add(self, start, end, replace=None):
        if self.text[start:end] == replace:
            return
        entry = [start - self._previous, end - start]
        if not self._grep:
            entry.append(replace)
        self._previous = end
        self._list.append(entry)

    def next(self, replace):
        c = self._list[self._index]
        pos = self._pos
        if replace:
            c = self._list[self._index]
            sub = c[2]
            self.text = self.text[:pos] + sub + self.text[pos + c[1]:]
            l = c[1] = len(sub)
            c[2] = True
        else:
            l = c[1]
            c[2] = False
        npos = pos + l
        if not self._chars:
            self._line_number += self.text.count('\n', pos, npos)
            self._line_printed = self._line_number + self.after + 1
        self._index += 1
        if not self.have():
            return False
        pos = npos
        npos = pos + self._list[self._index][0]
        if not self._chars:
            self._line_number += self.text.count('\n', pos, npos)
            self._line_start = linestart(self.text, npos)
        self._pos = npos
        return True

    def _pos_index_in_pattern(self, start):
        index = self._index
        in_pattern = False
        pos = self._pos
        while True:
            if in_pattern:
                npos = pos - self._list[index][1]
                if npos < start:
                    break
                pos = npos
                in_pattern = False
            else:
                if index == 0:
                    break
                npos = pos - self._list[index][0]
                if npos < start:
                    break
                pos = npos
                in_pattern = True
                index -= 1
        return (pos, index, in_pattern)

    def colored_filename(self, append=':'):
        if self.filename is None:
            return ''
        color = self.colors[5]
        if color:
            return (color + self.filename + self.colors.reset + append)
        return (self.filename + append)

    def _write_number(self, number, mode):
        if self._grep:
            mode = ''
        write('{0}{1}{2}:'.format(self.colored_filename(), number, mode))

    def _write_line_number(self, line_number, mode=' '):
        self._write_number(line_number + 1, mode)

    def _write_char_number(self, char_number, mode=' '):
        self._write_number(char_number + 1, mode)

    def _write_color(self, replace=None, index=None):
        if self._grep:
            color = self.colors[4]
        elif index is None:
            color = self.colors[2 + replace]
        else:
            replace = self._list[index][2]
            if isinstance(replace, bool):
                color = self.colors[replace]
            else:
                color = self.colors[4]
        if color:
            write(color)
            return self.colors.reset
        return None

    def _write_substring(self, start, end):
        self._write_printable(self.text[start:end])

    def _output_lines_before(self):
        if not self.before:
            return
        start = self._line_start
        line_number = self._line_number
        starts = []
        for i in range(self.before):
            if start == 0 or line_number - len(starts) <= self._line_printed:
                break
            start = linestart(self.text, start - 1)
            starts.append(start)
        if not starts:
            return
        line_number -= len(starts)
        prevstart = None
        for start in reversed(starts):
            if prevstart:
                self._write_line_number(line_number)
                self._write_substring(prevstart, start)
                line_number += 1
            prevstart = start
        self._write_line_number(line_number)
        self._write_substring(prevstart, self._line_start)

    def _output_to_lineend(self, current, pos, index, in_pattern):
        newline = self.text.find('\n', current)
        if newline < 0:
            newline = len(self.text)
            nextline = None
        else:
            newline += 1
            nextline = newline
        reset = None
        toggle = False
        while True:
            last = (pos is None or pos >= newline)
            if last:
                end = newline
            else:
                end = pos
            if current < end:
                if in_pattern:
                    reset = self._write_color(index=index)
                elif reset:
                    write(reset)
                    reset = None
                self._write_substring(current, end)
                current = end
            if last:
                break
            if in_pattern:
                in_pattern = False
                index += 1
                if index >= len(self._list):
                    pos = None
                else:
                    pos += self._list[index][0]
            else:
                in_pattern = True
                pos += self._list[index][1]
        if reset:
            write(reset)
        if nextline is None:
            print('<EOF>')
        elif nextline >= len(self.text):
            nextline = None
        return (nextline, pos, index, in_pattern)

    def _output_lines_at(self, pos, index, in_pattern, replace):
        if replace:
            mode = '+'
        else:
            mode = '-'
        line_number = self._line_number
        current = self._line_start
        self._write_line_number(line_number, mode=mode)
        reset = None
        if current < pos:
            if in_pattern:
                reset = self._wrote_color(index=index)
                in_pattern = False
            else:
                in_pattern = True
            self._write_substring(current, pos)
        while index < self._index:
            if in_pattern:
                reset = self._write_color(index=index)
                npos = pos + self._list[index][1]
                in_pattern = False
            else:
                if reset:
                    write(reset)
                    reset = None
                index += 1
                npos = pos + self._list[index][0]
                in_pattern = True
            self._write_substring(pos, npos)
            pos = npos
        current = pos
        pos += self._list[index][1]
        if replace:
            output = self._list[index][2]
        else:
            output = self.text[current:pos]
        output_current = 0
        newline = -1
        while output_current < len(output):
            if line_number > self._line_number:
                self._write_line_number(line_number, mode=mode)
            reset = self._write_color(replace=replace)
            newline = output.find('\n', output_current)
            if newline < 0:
                self._write_printable(output[output_current:])
                if reset:
                    write(reset)
                break
            newline += 1
            self._write_printable(output[output_current:newline])
            if reset:
                write(reset)
            output_current = newline
            line_number += 1
        current = pos
        index += 1
        if index < len(self._list):
            pos += self._list[index][0]
        else:
            pos = None
        if newline < 0:  # match does not close with newline
            (current, pos, index, in_pattern) = \
                self._output_to_lineend(current, pos, index, False)
        return (line_number + 1, current, pos, index, in_pattern)

    def _output_lines_after(self, startline, current, pos, index,
                            in_pattern):
        if not self.after:
            return
        for line_number in range(startline, startline + self.after):
            if current is None:
                break
            self._write_line_number(line_number)
            (current, pos, index, in_pattern) = \
                self._output_to_lineend(current, pos, index, in_pattern)

    def _output_lines_nogrep(self):
        self._output_lines_before()
        (pos, index, in_pattern) = self._pos_index_in_pattern(self._line_start)
        self._output_lines_at(pos, index, in_pattern, False)
        (startline, current, pos, index, in_pattern) = \
            self._output_lines_at(pos, index, in_pattern, True)
        self._output_lines_after(startline, current, pos, index, in_pattern)

    def _output_next_lines_grep(self):
        self._output_lines_before()
        current = self._line_start
        (pos, index, in_pattern) = self._pos_index_in_pattern(current)
        line_number = self._line_number
        lines_to_print = self.after + 1
        while lines_to_print > 0:
            self._write_line_number(line_number)
            (current, npos, index, in_pattern) = \
                self._output_to_lineend(current, pos, index, in_pattern)
            if current is None:
                return False
            line_number += 1
            if in_pattern:
                lines_to_print = self.after + 1
            elif pos is not None and (npos is None or npos != pos):
                lines_to_print = self.after
            else:
                lines_to_print -= 1
            pos = npos
        if pos is None:
            return False
        self._line_printed = line_number
        self._line_number = line_number + self.text.count('\n', current, pos)
        self._index = index
        self._pos = pos
        self._line_start = linestart(self.text, pos)
        return True

    def _output_chars(self, current, pos, index, in_pattern, finish):
        reset = None
        while True:
            last = (pos is None or pos >= finish)
            if last:
                end = finish
            else:
                end = pos
            if current < end:
                if in_pattern:
                    reset = self._write_color(index=index)
                elif reset:
                    write(reset)
                    reset = None
                self._write_substring(current, end)
                current = end
            if last:
                break
            if in_pattern:
                in_pattern = False
                index += 1
                if index >= len(self._list):
                    pos = None
                else:
                    pos += self._list[index][0]
            else:
                in_pattern = True
                pos += self._list[index][1]
        if reset:
            write(reset)

    def _output_chars_at(self, current, npos, replace, replace_empty,
                         b_pos, b_index, b_in_pattern,
                         e_pos, e_index, e_finish):
        if replace is not None:
            mode = '+'
        else:
            mode = '-'
        self._write_char_number(current, mode=mode)
        if self.before:
            self._output_chars(current, b_pos, b_index, b_in_pattern,
                               self._pos)
        if not replace_empty:
            reset = self._write_color(replace=not not replace)
            if replace is None:
                self._write_substring(self._pos, npos)
            else:
                self._write_printable(replace)
            if reset:
                write(reset)
        if self.after:
            self._output_chars(npos, e_pos, e_index, False, e_finish)
        print()

    def _output_chars_nogrep(self):
        current = self._pos
        match = self._list[self._index]
        match_len = match[1]
        npos = current + match_len
        if self.after:
            e_finish = npos + self.after
            if e_finish > len(self.text):
                e_finish = len(self.text)
            e_pos = None
            e_index = self._index + 1
            if e_index < len(self._list) and npos < e_finish:
                e_pos = npos + self._list[e_index][0]
        else:
            (e_current, e_pos, e_index, e_finish) = (None, None, None, None)
        if self.before:
            current -= self.before
            if current < 0:
                current = 0
            (b_pos, b_index, b_in_pattern) = \
                self._pos_index_in_pattern(current)
        else:
            (b_pos, b_index, b_in_pattern) = (None, None, None)
        self._output_chars_at(current, npos, None, not match_len,
                              b_pos, b_index, b_in_pattern,
                              e_pos, e_index, e_finish)
        replace = match[2]
        self._output_chars_at(current, npos, replace, not replace,
                              b_pos, b_index, b_in_pattern,
                              e_pos, e_index, e_finish)

    def _output_next_chars_grep(self):
        current = pos = self._pos
        if self.before:
            current -= self.before
            if current < 0:
                current = 0
        self._write_char_number(current)
        if current < pos:
            self._write_substring(current, pos)
        index = self._index
        npos = pos + self._list[index][1]
        in_pattern = True
        reset = None
        while True:
            if in_pattern:
                reset = self._write_color(index=index)
            elif npos > finish + self.before:
                break
            self._write_substring(pos, npos)
            if reset:
                write(reset)
                reset = None
            pos = npos
            if in_pattern:
                finish = npos + self.after + 1
                if finish > len(self.text):
                    finish = len(self.text)
                index += 1
                if index >= len(self._list):
                    npos = None
                    break
                npos += self._list[index][0]
                in_pattern = False
            else:
                npos += self._list[index][1]
                in_pattern = True
        if finish > len(self.text):
            finish = len(self.text)
        if pos < finish:
            self._write_substring(pos, finish)
        print()
        if npos is None:
            return False
        self._index = index
        self._pos = npos
        return True

    def __init__(self, text, grep=False, chars=False):
        self.before = 0
        self.after = 0
        self.colors = Colors()
        self.text = text
        self._grep = grep
        self._chars = chars
        self._list = []
        self._previous = 0
        if chars:
            self._write_printable = write_repr
            if grep:
                self.output_next_grep = self._output_next_chars_grep
            else:
                self.output_nogrep = self._output_chars_nogrep
        else:
            self._write_printable = write_printable
            if grep:
                self.output_next_grep = self._output_next_lines_grep
            else:
                self.output_nogrep = self._output_lines_nogrep


class Matcher:
    def __init__(self, search, replace=None, plain_search=False,
                 plain_replace=False, flags=0, quiet=False):
        self._quick = False
        if plain_search:
            search = re.sub(r'[a-zA-Z_]', r'\\\0', search)
        self._re = re.compile(search, flags)
        if replace is None:
            self._plain_replace = True
            self._replace = None
            if quiet:
                self._quick = True
            return
        if plain_replace:
            self._plain_replace = True
            self._replace = replace
        elif have_sre_parse:  # cf _subx() in re.py for the undocumented usage:
            template = sre_parse.parse_template(replace, self._re)
            if not template[0] and len(template[1]) == 1:
                self._plain_replace = True
                self._replace = template[1][0]
            else:
                self._plain_replace = False
                self._replace = template
        else:  # poor man's fallback
            self._plain_replace = False
            self._replace = replace

    def get_match_list(self, text, chars=False):
        match_list = MatchList(text, grep=(self._replace is None), chars=chars)
        for match in self._re.finditer(text):
            if self._plain_replace:
                replace = self._replace
            elif have_sre_parse:
                replace = sre_parse.expand_template(self._replace, match)
            else:   # poor man's fallback:
                replace = match.expand(self._replace)
            match_list.add(match.start(), match.end(), replace)
            if self._quick:
                return match_list
        match_list.finalize()
        return match_list


def ask_replace():
    msg = 'y(es)/n(o)/r(est of file)/q(uit this file)/a(lways)' \
          '/A(lways quiet)/s(top all) '
    while True:
        answer = my_input(msg)
        if answer == 's':
            sys.exit(0)
        if answer in ['y', 'n', 'r', 'q', 'a', 'A']:
            return answer


def ask_write(filename):
    msg = 'write changes to {0}? y(es)/n(o)/w(rite always)/s(top all) '. \
        format(filename)
    while True:
        answer = my_input(msg)
        if answer == 's':
            sys.exit(0)
        if answer in ['y', 'n', 'w']:
            return answer


def close_noexcept(file):
    try:
        file.close()
    except Exception:
        pass


class Action:
    def _slurp(self, filename, encoding_override=None):
        self._encoding_override = encoding_override  # Remember for writing
        if encoding_override:
            encoding = encoding_override
        else:
            encoding = self._encoding
        try:
            file = codecs.open(filename, 'rb', encoding=encoding)
        except Exception as e:
            warn('cannot open {0} for reading: {1}'.format(filename, e))
            return None
        try:
            text = file.read()
        except UnicodeDecodeError as e:
            if encoding_override:
                warn('fallback encoding fails, too: {0}'.format(e))
                return None
            close_noexcept(file)
            if self._encoding_fallback and self._encoding_fallback != encoding:
                warn('switching encoding {0}->{1} for {2}: {3}'.
                     format(self._encoding, self._encoding_fallback,
                            filename, e))
                return self._slurp(filename, self._encoding_fallback)
            warn('{0} encoding error for {1}: {2}'.
                 format(self._encoding, filename, e))
            return None
        except Exception as e:
            close_noexcept(file)
            warn('error when reading {0}: {1}'.format(filename, e))
            return None
        try:
            file.close()
        except Exception as e:
            warn('error when closing {0} after reading: {1}'.
                 format(filename, e))
            return None
        return text

    def _write(self, filename, text):
        stat = None
        if self._keep:
            try:
                stat = os.stat(filename)
            except Exception as e:
                stat = None
                warn('cannot get timestamp of {0}: {1}'.format(filename, e))
        if self._encoding_override is not None:
            encoding = self._encoding_override
        else:
            encoding = self._encoding
        try:
            file = codecs.open(filename, 'wb', encoding=encoding)
        except Exception as e:
            warn('cannot open {0} for writing: {1}'.format(filename, e))
            return
        try:
            file.write(text)
        except Exception as e:
            warn('write error to {0}: {1}'.format(filename, e))
        try:
            file.close()
        except Exception as e:
            warn('cannot close {0} after writing: {1}'.format(filename, e))
        if stat is not None:
            try:
                os.utime(filename, (stat.st_atime, stat.st_mtime))
            except Exception as e:
                warn('cannot set timestamp of {0}: {1}'.format(filename, e))

    def _exit(self):
        if self._replace is None and not self._have:
            sys.exit(1)  # grep mode with no match
        sys.exit(0)

    def _process(self, filename):
        text = self._slurp(filename)
        if text is None:
            return
        match_list = self._matcher.get_match_list(text, self._chars)
        match_list.colors = self._colors
        match_list.before = self._before
        match_list.after = self._after
        match_list.filename = filename
        have = (not match_list.empty())
        if self._replace is None:
            if have:
                self._have = True
                if self._quiet:
                    self._exit()
                if self._list:
                    print(match_list.colored_filename(append=''))
                    return
            if self._quiet:
                return
            if self._count:
                print('{0}{1}'.format(match_list.colored_filename(),
                                      match_list.length()))
                return
            while have:
                have = match_list.output_next_grep()
            return
        rest = self._always_replace
        changed = False
        while have:
            if not self._quiet:
                match_list.output_nogrep()
            replace = False
            if rest:
                replace = True
            else:
                answer = ask_replace()
                if answer == 'y':
                    replace = True
                elif answer == 'r':
                    replace = rest = True
                elif answer == 'a':
                    replace = rest = self._always_replace = True
                elif answer == 'A':
                    replace = rest = self._always_replace = self._quiet = True
                elif answer == 'q':
                    break
            if replace:
                changed = True
            have = match_list.next(replace)
        if not changed:
            return
        write = self._always_write
        if not write:
            answer = ask_write(filename)
            if answer == 'y':
                write = True
            elif answer == 'w':
                write = self._always_write = True
        if write:
            self._write(filename, match_list.text)

    def _test_skip(self, filename):
        for skip in self._skip:
            if fnmatch.fnmatch(filename, skip):
                return True
        return False

    def _recurse(self, dir):
        for (dirpath, dirnames, filenames) in os.walk(dir):
            dirnames[:] = \
                [name for name in sorted(dirnames)
                 if not self._test_skip(os.path.join(dirpath, name))]
            for name in sorted(filenames):
                filename = os.path.join(dirpath, name)
                if not self._test_skip(filename) and os.path.isfile(filename):
                    self._process(filename)

    def _parse_error(self, msg):
        self._parser.print_usage(file=sys.stderr)
        raise argparse.ArgumentTypeError(msg)

    def _main(self):
        self._parser = get_parser()
        options = self._parser.parse_args()
        self._debug = options.debug
        self._chars = options.chars
        files = options.files
        if options.grep or options.count or options.list:
            if options.replace is not None:
                files.insert(0, options.replace)
            self._replace = options.replace = None
            self._list = options.list
            self._count = options.count
        else:
            self._replace = options.replace
        if not files:
            self._parse_error('no files specified')
        self._colors = Colors(options.colors)
        self._before = self._after = options.context
        if options.before is not None:
            self._before = options.before
        if options.after is not None:
            self._after = options.after
        if self._before < 0:
            self._parse_error(
                '--before argument {0} is negative'.format(self._before))
        if self._after < 0:
            self._parse_error(
                '--after argument {0} is negative'.format(self._after))
        flags = 0
        if options.ignorecase:
            flags |= re.IGNORECASE
        if options.multiline:
            flags |= re.MULTILINE
        if options.dotall:
            flags |= re.DOTALL
        if options.unicode:
            flags |= re.UNICODE
        if options.locale:
            flags |= re.LOCALE
        if options.verbose:
            flags |= re.VERBOSE
        self._encoding = options.encoding
        self._encoding_fallback = options.encoding_fallback
        self._keep = options.keep
        self._quiet = options.quiet
        self._skip = options.skip
        if options.yes:
            self._always_replace = True
        else:
            self._always_replace = False
        if options.yes > 1:
            self._always_write = True
        else:
            self._always_write = False
        self._matcher = Matcher(
            options.search, self._replace,
            plain_search=options.plain_search,
            plain_replace=options.plain_replace,
            flags=flags,
            quiet=self._quiet,
        )
        for filename in files:
            if self._test_skip(filename):
                continue
            if os.path.isfile(filename):
                self._process(filename)
            elif os.path.isdir(filename):
                if options.recursive:
                    self._recurse(filename)
                else:
                    warn('forgotten --recursive: directory: {0}'.
                         format(filename))
            else:
                warn('not an accessible file: {0}'.format(filename))

    def __init__(self):
        self._debug = False
        try:
            locale.setlocale(locale.LC_ALL, '')
            self._main()
        except KeyboardInterrupt:
            sys.exit(130)
        except SystemExit:
            raise
        except Exception as e:
            if self._debug:
                raise
            eprint('{0}: {1}'.format(type(e).__name__, e))
            sys.exit(2)

Action()
